# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EcuHsQ-4JPXkWSrtn4Mf3oxQsVwHLJ47
"""

import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import random
import joblib
import math
np.random.seed(42)
random.seed(42)

# --- Sales historical data (daily) ---
start = datetime(2023,1,1)
days = 800
dates = [start + timedelta(days=i) for i in range(days)]
trend = np.linspace(100, 250, days)
seasonal = 20 * np.sin(np.arange(days) * (2*np.pi/30))
noise = np.random.normal(0, 12, days)
sales = np.round(trend + seasonal + noise).astype(int)
sales_df = pd.DataFrame({'date': dates, 'sales': sales})

# --- IoT sensor data (machines) hourly for 90 days ---
machines = [f"MC_{i:02d}" for i in range(1,11)]
hours = 24*90
ts = [datetime(2025,1,1) + timedelta(hours=i) for i in range(hours)]
rows = []
for m in machines:
    base_temp = 60 + np.random.randn()*2
    base_vib = 0.5 + np.random.rand()*0.2
    for t in ts:
        temp = base_temp + 0.02*( (t - ts[0]).days ) + np.random.normal(0,0.8)
        vib = base_vib + np.random.normal(0,0.05)
        runtime = np.random.randint(0,60)
        rows.append([m, t, temp, vib, runtime])
iot_df = pd.DataFrame(rows, columns=['machine_id','timestamp','temperature','vibration','runtime_mins'])

# --- Customers for route optimisation ---
depot = (10,10)
num_customers = 12
customers = []
for i in range(1,num_customers+1):
    x = 10 + np.random.randint(-9, 10)
    y = 10 + np.random.randint(-9, 10)
    demand = np.random.randint(1,5)
    customers.append({'id': i, 'x': x, 'y': y, 'demand': demand})
customers_df = pd.DataFrame(customers)

# Save sample files (optional)
sales_df.to_csv('sales_history.csv', index=False)
iot_df.to_csv('iot_hourly.csv', index=False)
customers_df.to_csv('customers.csv', index=False)

print("Sample data created: sales_history.csv, iot_hourly.csv, customers.csv")

sales_df['date'] = pd.to_datetime(sales_df['date'])
sales_df = sales_df.set_index('date').asfreq('D')
sales_df['sales'] = sales_df['sales'].fillna(method='ffill')


iot_df['timestamp'] = pd.to_datetime(iot_df['timestamp'])
iot_daily = (iot_df.assign(date=iot_df['timestamp'].dt.date)
                    .groupby(['machine_id','date'])
                    .agg({'temperature':'mean','vibration':'mean','runtime_mins':'sum'})
                    .reset_index())
iot_daily['date'] = pd.to_datetime(iot_daily['date'])


print("Sales shape:", sales_df.shape)
print("IoT daily shape:", iot_daily.shape)
display(sales_df.head(), iot_daily.head())

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Giả sử bạn có dữ liệu monthly_sales (tổng doanh số mỗi tháng)
np.random.seed(42)
monthly_sales = np.random.normal(15000, 2000, 50)  # ví dụ dữ liệu

plt.figure(figsize=(8,5))
sns.histplot(monthly_sales, kde=True, color='purple', stat='density')
plt.title("Distribution of Monthly Sales")
plt.xlabel("Monthly Sales")
plt.ylabel("Probability")
plt.grid(alpha=0.3)
plt.show()

import matplotlib.pyplot as plt

# Giả sử bạn có dữ liệu tháng và lợi nhuận
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug']
profits = [2000, 2450, 2500, 2900, 2800, 3100, 3300, 3600]

plt.figure(figsize=(8,5))
plt.plot(months, profits, marker='o', color='green', linewidth=2)
plt.title("Monthly Profit Trend")
plt.xlabel("Month")
plt.ylabel("Profit")
plt.grid(alpha=0.3)
plt.show()

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, roc_auc_score

df = iot_daily.copy().sort_values(['machine_id','date'])
df['temp_prev'] = df.groupby('machine_id')['temperature'].shift(1)
df['temp_delta'] = df['temperature'] - df['temp_prev']
df['vib_prev'] = df.groupby('machine_id')['vibration'].shift(1)

# Create synthetic label: failure_next if vibration > 0.9 or temp_delta > 2
df['failure_next'] = ((df['vibration'] > 0.9) | (df['temp_delta'] > 2)).astype(int)
df = df.dropna(subset=['temp_prev'])  # drop rows w/o prev

features = ['temperature','vibration','runtime_mins','temp_delta']
X = df[features]
y = df['failure_next']

# Train/Test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

clf = RandomForestClassifier(n_estimators=150, random_state=42, class_weight='balanced')
clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)
print(classification_report(y_test, y_pred))
try:
    print("ROC AUC:", roc_auc_score(y_test, clf.predict_proba(X_test)[:,1]))
except:
    pass

# Save model
joblib.dump(clf, 'rf_maintenance_model.joblib')
print("Saved rf_maintenance_model.joblib")

from ortools.constraint_solver import pywrapcp, routing_enums_pb2

# Build coordinates incl depot
locations = [(depot[0], depot[1])] + [(row.x, row.y) for _, row in customers_df.iterrows()]
def euclid(a,b):
    return int(math.hypot(a[0]-b[0], a[1]-b[1]))

n = len(locations)
dist_matrix = [[euclid(locations[i], locations[j]) for j in range(n)] for i in range(n)]
demands = [0] + customers_df['demand'].tolist()
vehicle_capacity = 15
num_vehicles = 3
depot_index = 0

manager = pywrapcp.RoutingIndexManager(len(dist_matrix), num_vehicles, depot_index)
routing = pywrapcp.RoutingModel(manager)

def distance_callback(from_index, to_index):
    return dist_matrix[manager.IndexToNode(from_index)][manager.IndexToNode(to_index)]
transit_cb_idx = routing.RegisterTransitCallback(distance_callback)
routing.SetArcCostEvaluatorOfAllVehicles(transit_cb_idx)

# Capacity
def demand_callback(from_index):
    return demands[manager.IndexToNode(from_index)]
demand_cb_idx = routing.RegisterUnaryTransitCallback(demand_callback)
routing.AddDimensionWithVehicleCapacity(demand_cb_idx, 0, [vehicle_capacity]*num_vehicles, True, 'Capacity')

search_params = pywrapcp.DefaultRoutingSearchParameters()
search_params.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
search_params.time_limit.FromSeconds(10)
solution = routing.SolveWithParameters(search_params)

def extract_routes(sol):
    routes = []
    for v in range(num_vehicles):
        idx = routing.Start(v)
        route = []
        while not routing.IsEnd(idx):
            node = manager.IndexToNode(idx)
            route.append(node)
            idx = sol.Value(routing.NextVar(idx))
        route.append(manager.IndexToNode(idx))
        routes.append(route)
    return routes

routes = extract_routes(solution)
for i, r in enumerate(routes):
    print(f"Vehicle {i+1}: ", end="")
    for node in r:
        if node==0:
            print("Depot -> ", end="")
        else:
            cust = customers_df.iloc[node-1]
            print(f"Cust{cust.id}(d={cust.demand}) -> ", end="")
    print("End")

sales_df.reset_index().to_csv('sales_history.csv', index=False)
iot_daily.to_csv('iot_daily.csv', index=False)
customers_df.to_csv('customers.csv', index=False)
joblib.dump({'routes':routes, 'customers':customers_df.to_dict(orient='records')}, 'route_plan.joblib')
print("Saved CSVs and route_plan.joblib")

import pandas as pd

# Load từ file nếu bạn đã lưu
sales_df = pd.read_csv('sales_history.csv', parse_dates=['date']).set_index('date')
print("sales_df:", sales_df.shape)
try:
    iot_daily = pd.read_csv('iot_daily.csv', parse_dates=['date'])
    print("iot_daily:", iot_daily.shape)
except FileNotFoundError:
    print("Không tìm iot_daily.csv — hãy chạy cell tạo data mẫu trước.")

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

# đảm bảo sales_df có datetime index
if not isinstance(sales_df.index, pd.DatetimeIndex):
    sales_df.index = pd.to_datetime(sales_df.index)

# Kiểm tra model tồn tại
if 'arima_model' not in globals():
    raise RuntimeError("arima_model chưa tồn tại — chạy bước train/load model trước (Bước 2).")

n_forecast = 90
fc, confint = arima_model.predict(n_periods=n_forecast, return_conf_int=True)

# Tạo index cho forecast
idx = pd.date_range(start=sales_df.index[-1] + pd.Timedelta(days=1), periods=n_forecast, freq='D')

# Debug checks
print("len(fc)=", len(fc), " idx len=", len(idx))
print("confint.shape=", np.shape(confint))
if len(fc) != len(idx):
    raise ValueError("Số ngày forecast không khớp với index. Kiểm tra n_forecast và dữ liệu.")

# Convert to Series
fc_series = pd.Series(fc, index=idx)
lower = pd.Series(confint[:,0], index=idx)
upper = pd.Series(confint[:,1], index=idx)

# Plot
plt.figure(figsize=(12,6))
plt.plot(sales_df['sales'][-180:], label='Lịch sử (180 ngày)', linewidth=1.5)
plt.plot(fc_series, label=f'Dự báo ({n_forecast} ngày)', linewidth=1.5)
plt.fill_between(idx, lower, upper, color='orange', alpha=0.25, label='Confidence interval')
plt.xlabel('Ngày')
plt.ylabel('Số lượng bán')
plt.title('Lịch sử và Dự báo doanh số')
plt.legend()
plt.grid(alpha=0.3)
plt.show()

import seaborn as sns

# Lấy dữ liệu 7 ngày cuối
iot_recent = iot_daily.groupby('machine_id').tail(7)
iot_avg = iot_recent.groupby('machine_id').mean().reset_index()

# Barplot nhiệt độ
plt.figure(figsize=(10,5))
sns.barplot(x='machine_id', y='temperature', data=iot_avg, palette='coolwarm')
plt.title('Nhiệt độ trung bình (7 ngày gần nhất)')
plt.xlabel('Máy')
plt.ylabel('Nhiệt độ (°C)')
plt.show()

# Barplot độ rung
plt.figure(figsize=(10,5))
sns.barplot(x='machine_id', y='vibration', data=iot_avg, palette='viridis')
plt.title('Độ rung trung bình (7 ngày gần nhất)')
plt.xlabel('Máy')
plt.ylabel('Độ rung (g)')
plt.show()

import pandas as pd
import numpy as np

# Nếu đã có file sales_history.csv
sales_df = pd.read_csv('sales_history.csv', parse_dates=['date'])
sales_df = sales_df.sort_values('date')

# Đảm bảo dữ liệu đủ dạng số ngày
sales_df['day_num'] = np.arange(len(sales_df))  # Biến thời gian dạng số
sales_df.head()

from sklearn.model_selection import train_test_split

X = sales_df[['day_num']]
y = sales_df['sales']

# Chia 80% train, 20% test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

from sklearn.linear_model import LinearRegression

# Tạo và huấn luyện model
lin_reg_model = LinearRegression()
lin_reg_model.fit(X_train, y_train)

# Kiểm tra hệ số
print("Hệ số góc:", lin_reg_model.coef_[0])
print("Hệ số chặn:", lin_reg_model.intercept_)

# Ngày bắt đầu dự báo
last_day_num = sales_df['day_num'].iloc[-1]
future_days = np.arange(last_day_num+1, last_day_num+31).reshape(-1, 1)

# Dự báo
future_forecast = lin_reg_model.predict(future_days)

# Tạo DataFrame kết quả
future_dates = pd.date_range(start=sales_df['date'].iloc[-1] + pd.Timedelta(days=1), periods=30)
forecast_df = pd.DataFrame({'date': future_dates, 'forecast_sales': future_forecast})

forecast_df.head()

import matplotlib.pyplot as plt

plt.figure(figsize=(12,6))
plt.plot(sales_df['date'], sales_df['sales'], label='Doanh số thực tế', color='blue')
plt.plot(forecast_df['date'], forecast_df['forecast_sales'], label='Dự báo (Linear Regression)', color='orange')
plt.xlabel('Ngày')
plt.ylabel('Số lượng bán')
plt.title('Dự báo doanh số 30 ngày tiếp theo')
plt.legend()
plt.grid(True)
plt.show()

# Plot routes from OR-Tools solution
plt.figure(figsize=(8,8))
# Vẽ depot
plt.scatter(depot[0], depot[1], c='red', s=100, label='Depot')
# Vẽ khách hàng
plt.scatter(customers_df['x'], customers_df['y'], c='blue', s=60, label='Khách hàng')

colors = ['green','orange','purple','cyan','magenta']
for v, route in enumerate(routes):
    for i in range(len(route)-1):
        start_node = route[i]
        end_node = route[i+1]
        if start_node == 0:
            start_coord = depot
        else:
            start_coord = (customers_df.iloc[start_node-1]['x'], customers_df.iloc[start_node-1]['y'])
        if end_node == 0:
            end_coord = depot
        else:
            end_coord = (customers_df.iloc[end_node-1]['x'], customers_df.iloc[end_node-1]['y'])
        plt.plot([start_coord[0], end_coord[0]], [start_coord[1], end_coord[1]],
                 color=colors[v % len(colors)], linewidth=2)

plt.legend()
plt.title('Sơ đồ tuyến đường giao hàng')
plt.xlabel('Tọa độ X')
plt.ylabel('Tọa độ Y')
plt.grid(True)
plt.show()

from statsmodels.tsa.arima.model import ARIMA
import joblib

# Fit ARIMA model
# Choosing a simple order (5,1,0) as a starting point.
# In a real scenario, model order selection (p,d,q) should be done carefully
# (e.g., using auto_arima, ACF/PACF plots, information criteria).
arima_model = ARIMA(sales_df['sales'], order=(5,1,0))
arima_model_fit = arima_model.fit()

# Save the fitted model
joblib.dump(arima_model_fit, 'arima_sales_model.joblib')

print("ARIMA model trained and saved as arima_sales_model.joblib")

import pandas as pd
import matplotlib.pyplot as plt

# Thêm cột Quý
sales_df['Quarter'] = sales_df.index.to_period('Q')

# Tính tổng doanh số theo quý
quarterly_sales = sales_df.groupby('Quarter')['sales'].sum()

# Vẽ biểu đồ tròn
plt.figure(figsize=(8,8))
colors = ['#ff9999','#66b3ff','#99ff99','#ffcc99']
plt.pie(quarterly_sales, labels=quarterly_sales.index.astype(str),
        autopct='%1.1f%%', startangle=90, colors=colors, wedgeprops={'edgecolor':'black'})
plt.title('Sales Share by Quarter', fontsize=16)
plt.axis('equal')  # giữ tròn
plt.show()

# Meaning
print("Meaning: This pie chart shows the proportion of sales in each quarter, "
      "helping to identify which quarters contribute most to annual revenue.")

# Robust RMSE calculation (works with both old & new sklearn)
import numpy as np
from sklearn.metrics import mean_absolute_error, mean_squared_error
import sklearn

print("scikit-learn version:", sklearn.__version__)

# đảm bảo y_pred_test có
y_pred_test = lin_reg.predict(X_test)  # nếu bạn đã có y_pred_test thì OK

mae = mean_absolute_error(y_test, y_pred_test)

# thử dùng tham số squared (mới), nếu không được thì fallback về sqrt(MSE)
try:
    rmse = mean_squared_error(y_test, y_pred_test, squared=False)
except TypeError:
    rmse = np.sqrt(mean_squared_error(y_test, y_pred_test))

import joblib
try:
    # Load the fitted ARIMA model
    arima_model = joblib.load('arima_sales_model.joblib')
    print("ARIMA model loaded from arima_sales_model.joblib")
except FileNotFoundError:
    print("Error: arima_sales_model.joblib not found. Please train the model first.")
    arima_model = None # Ensure arima_model is None if file not found

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error
import sklearn

print("scikit-learn version:", sklearn.__version__)
dates = pd.date_range(start='2023-01-01', periods=365, freq='D')
sales = np.random.randint(80, 200, size=(365,)) + np.linspace(0, 50, 365)
sales_df = pd.DataFrame({'date': dates, 'sales': sales})
sales_df['day_num'] = np.arange(len(sales_df))
train_size = int(len(sales_df) * 0.8)
train = sales_df.iloc[:train_size]
test = sales_df.iloc[train_size:]
X_train, y_train = train[['day_num']], train['sales']
X_test, y_test = test[['day_num']], test['sales']
lin_reg = LinearRegression()
lin_reg.fit(X_train, y_train)
last_day_num = sales_df['day_num'].iloc[-1]
future_days = np.arange(last_day_num + 1, last_day_num + 31).reshape(-1, 1)
future_forecast = lin_reg.predict(future_days)
future_dates = pd.date_range(start=sales_df['date'].iloc[-1] + pd.Timedelta(days=1), periods=30)

forecast_df = pd.DataFrame({'date': future_dates, 'forecast_sales': future_forecast})

plt.figure(figsize=(12,6))
plt.plot(sales_df['date'], sales_df['sales'], label='Actual Sales', color='blue')
plt.plot(forecast_df['date'], forecast_df['forecast_sales'], label='Forecast (30 days)', color='orange')
plt.xlabel('Date')
plt.ylabel('Sales')
plt.title('Sales Forecast using Linear Regression')
plt.legend()
plt.grid(True)
plt.show()

y_pred_test = lin_reg.predict(X_test)
mae = mean_absolute_error(y_test, y_pred_test)

try:
    rmse = mean_squared_error(y_test, y_pred_test, squared=False)
except TypeError:
    rmse = np.sqrt(mean_squared_error(y_test, y_pred_test))

print(f"MAE: {mae:.2f}")
print(f"RMSE: {rmse:.2f}")

print("Meaning: The Linear Regression model predicts the sales trend for the next 30 days "
      "based on historical data. This helps in planning inventory, "
      "allocating resources, and identifying growth patterns.")